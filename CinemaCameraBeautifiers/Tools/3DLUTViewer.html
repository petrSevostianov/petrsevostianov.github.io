<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D LUT Viewer</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:Inter,Segoe UI,Arial}
    #canvas{display:block;width:100%;height:100%;background:#f5f5f5}
    .notice{position:fixed;left:8px;top:8px;background:rgba(255,255,255,0.95);padding:6px 10px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,0.12);font-size:13px;z-index:10}
    .warning{position:fixed;right:8px;top:8px;background:#fff4e5;padding:6px 10px;border-radius:6px;border:1px solid #e6b87a;color:#6a4b00;font-size:13px}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="notice">Drag to rotate • Right-drag: pan • Scroll to zoom</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>


  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/controls/OrbitControls.js';

    function ShowError(message) {
      console.error(message);
    }

    function GetLutUrl() {
      const params = new URLSearchParams(window.location.search);
      return params.get('lut');
    }

    function LoadLUT(url, onLoad){
      fetch(url).then(res => {
        if (!res.ok) {
          ShowError(`Failed to load LUT: ${res.status} ${res.statusText}`);
          return;
        }
        return res.text();
      }).then(text => {
        if (text) {
          onLoad(text);
        }
      }).catch(err => {
        ShowError(`Error loading LUT: ${err.message}`);
      });
    }

    /*const params = new URLSearchParams(window.location.search);
    const lutPath = params.get('lut');
    console.log('LUT path:', lutPath);

    //load lut file content if provided
    if (lutPath) {
      fetch(lutPath).then(res => {
        if (!res.ok) {
          throw new Error(`Failed to load LUT file: ${res.status} ${res.statusText}`);
        }
        return res.text();
      }).then(text => {
        console.log('LUT file content:', text);
      }).catch(err => {
        console.error(err);
      })
    }*/

    function BuildIdentityLUT(n = 17) {
      const arr = [];
      for (let b = 0; b < n; b++)
      for (let g = 0; g < n; g++)
      for (let r = 0; r < n; r++) {
        arr.push([r / (n - 1), g / (n - 1), b / (n - 1)]);
      }
      return arr;
    }

    function Setup3DScene(lutData) {


      const canvas = document.getElementById('canvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x808080);

      const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.01, 50);
      //camera.position.set(1.5, 1.2, 1.8);


      const controls = new OrbitControls( camera, renderer.domElement );
      // controls.update() must be called after any manual changes to the camera's transform
      camera.position.set( -2, 1, -1 );
      controls.target.set( 0.5, 0.5, 0.5 );
      controls.update();

      // Helpers
      const axes = new THREE.AxesHelper(1);
      scene.add(axes);

      


      // Render LUT as point cloud
      function AddLUTToScene(data, pointSize = 0.02) {
        const prev = scene.getObjectByName('lut_points');
        if (prev) {
          prev.geometry.dispose();
          if (prev.material) prev.material.dispose();
          scene.remove(prev);
        }
        let lutSize = Math.cbrt(data.length);
        const positions = new Float32Array(data.length * 3);
        const colors = new Float32Array(data.length * 3);

        let index = 0;
        for (let b = 0; b < lutSize; b++) {
          for (let g = 0; g < lutSize; g++) {
            for (let r = 0; r < lutSize; r++) {
              let sr = r / (lutSize - 1);
              let sg = g / (lutSize - 1);
              let sb = b / (lutSize - 1);
              const [dr, dg, db] = data[index];
              positions[index * 3 + 0] = dr;
              positions[index * 3 + 1] = dg;
              positions[index * 3 + 2] = db;
              colors[index * 3 + 0] = sr;
              colors[index * 3 + 1] = sg;
              colors[index * 3 + 2] = sb;
              index++;
              
            }
          }
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const mat = new THREE.PointsMaterial({ size: pointSize, vertexColors: true, sizeAttenuation: true });
        const pts = new THREE.Points(geom, mat);
        pts.name = 'lut_points';
        scene.add(pts);
        return pts;
      }

      // --- Run tests (keep existing tests, add one extra) ---
      //const identity = buildIdentityLUT(17);
      AddLUTToScene(lutData, 0.02);


      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        if (controls && controls.update) controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Resize handling
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function ParseLUTText(lutText) {
      const lines = lutText.split('\n');
      const data = [];
      for (let line of lines) {
        line = line.trim();
        if (line === '' || line.startsWith('#')) {
          continue; // skip empty lines and comments
        }
        const parts = line.split(/\s+/);
        if (parts.length >= 3) {
          const r = parseFloat(parts[0]);
          const g = parseFloat(parts[1]);
          const b = parseFloat(parts[2]);
          //if all parts are floats
          if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            data.push([r, g, b]);
          }
        }
      }
      return data;
    }

    let lutUrl = GetLutUrl();
    LoadLUT(lutUrl, (lutText) => {
      let lutData = ParseLUTText(lutText);
      Setup3DScene(lutData);

    });

  </script>
</body>
</html>
